<!DOCTYPE html>
<html lang="en">
  <head>
    <title>six</title>
    <meta name="description" content="six">
    <link id="favicon" rel="icon" href="https://glitch.com/edit/favicon-app.ico" type="image/x-icon">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/style.css">
  </head>
  <body>
    <header>
      <h1>
        six
      </h1>
      <p>
        <a href="//adventofcode.com/2018/day/6">adventofcode.com/2018/day/6</a>
      </p>
    </header>

    <main>
      <h2>
        part 1
      </h2>
      <form method="POST" action="/day06part1">
        <textarea id="input1" name="input" placeholder="input" cols="40" rows="5"></textarea>
        <code id="part1"></code>
        <!-- <input type="submit" /> -->
      </form>
      <hr />
      <h2>
        part 2
      </h2>
      <form method="POST" action="/day06part2">
        <textarea id="input2" name="input" placeholder="input" cols="40" rows="5"></textarea>   
        <code id="part2"></code>
        <!-- <input type="submit" /> -->
      </form>
    </main>

    <footer>
      Made with <a href="https://glitch.com">Glitch</a>!
    </footer>
    
    <script>
      const input1 = document.getElementById("input1");
      const part1 = document.getElementById('part1');
      
      const getDist = function(a, b) {
          const dy = Math.abs(a[0] - b[0]);
          const dx = Math.abs(a[1] - b[1]);
          return dx + dy;    
      };
      
      input1.addEventListener("change", ev => {
        const data1 = input1.value.trim().split("\n");
        
        const coords = data1.map(xy => xy.split(", ").map(Number));
        const maxy = coords.reduce((max, xy) => { return Math.max(max, xy[0]); }, 0);
        const maxx = coords.reduce((max, xy) => { return Math.max(max, xy[1]); }, 0);
        //console.log(coords);
        
        let grid = [];
        for (let y = 0; y <= maxy; y++) {
          grid[y] = grid[y] || []; 
          for (let x = 0; x <= maxx; x++) {
            let minPoints = coords.reduce((points, point, idx) => {
              //console.info(idx, point);
              if (points.length === 0) {
                points.push(idx);
              } else {
                let distThis = getDist([y, x], point);
                let distPrev = getDist([y, x], coords[points[0]]);
                //console.info(distThis, distPrev, points);
                if (distThis === distPrev) {
                  points.push(idx);
                } else if (distThis < distPrev) {
                  points = [idx];
                }
              }
              
              return points;
            }, []);
            
            if (minPoints.length === 1) {
              grid[y][x] = minPoints[0];
            } else {
              grid[y][x] = null;
            }
          }
        }
        
        //console.table(grid);
        
        let closestCounts = {};
        grid.forEach(y => y.forEach(x => {
          if (x !== null) {
            closestCounts[x] = closestCounts[x] || 0;
            closestCounts[x]++;
          }
        }));
        
        // skip the infinite ones
        const yedges = [-1, maxy + 1];
        const xedges = [-1, maxx + 1];
        
        yedges.forEach(y => {
          for (let x = xedges[0]; x <= xedges[1]; x++) {
            let minPoints = coords.reduce((points, point, idx) => {
              //console.info(idx, point);
              if (points.length === 0) {
                points.push(idx);
              } else {
                let distThis = getDist([y, x], point);
                let distPrev = getDist([y, x], coords[points[0]]);
                //console.info(distThis, distPrev, points);
                if (distThis === distPrev) {
                  points.push(idx);
                } else if (distThis < distPrev) {
                  points = [idx];
                }
              }
              
              return points;
            }, []);
            
            if (minPoints.length === 1) {
              coords[minPoints[0]].push(true);
            }
          }
        });
        
        xedges.forEach(x => {
          for (let y = yedges[0]; y <= yedges[1]; y++) {
            let minPoints = coords.reduce((points, point, idx) => {
              //console.info(idx, point);
              if (points.length === 0) {
                points.push(idx);
              } else {
                let distThis = getDist([y, x], point);
                let distPrev = getDist([y, x], coords[points[0]]);
                //console.info(distThis, distPrev, points);
                if (distThis === distPrev) {
                  points.push(idx);
                } else if (distThis < distPrev) {
                  points = [idx];
                }
              }
              
              return points;
            }, []);
            
            if (minPoints.length === 1) {
              coords[minPoints[0]].push(true);
            }
          }
        });
        
        const theMax = Object.keys(closestCounts).reduce((maxItem, key) => {
          if (coords[key].length === 2 && closestCounts[key] > maxItem.count) {
            maxItem = { key: key, count: closestCounts[key] };
          }
          
          return maxItem;
        }, { key: -1, count: 0 });
        
        // not 90, not 72, not 7593, yes 5333
        part1.innerText = theMax.count;
      });
      
      const input2 = document.getElementById("input2");
      const part2 = document.getElementById('part2');
      
      input2.addEventListener("change", ev => {
        const MAX_DIST = 10000;
        const data2 = input2.value.trim().split("\n");
        
        const coords = data2.map(xy => xy.split(", ").map(Number));
        const maxy = coords.reduce((max, xy) => { return Math.max(max, xy[0]); }, 0);
        const maxx = coords.reduce((max, xy) => { return Math.max(max, xy[1]); }, 0);
        
        let grid = [];
        for (let y = 0; y <= maxy; y++) {
          grid[y] = grid[y] || []; 
          for (let x = 0; x <= maxx; x++) {
            grid[y][x] = 0;
            
            // calculate total distance from all coords
            coords.every((point) => {
              let distThis = getDist([y, x], point);
              grid[y][x] += distThis;
              // break if max is exceeded
              return grid[y][x] < MAX_DIST;
            });
          }
        }
        
        //console.table(grid);
        
        const size = grid.reduce((ytotal, y, yi) => {
          ytotal += y.reduce((xtotal, x, xi) => {
            if (x < MAX_DIST) {
              xtotal++;
              //console.info(yi, xi, x);
            }
            return xtotal;
          }, 0);
          return ytotal;
        }, 0);
        
        part2.innerText = size;
      });
      
    </script>

    <div class="glitchButton"></div>
    <script src="https://button.glitch.me/button.js"></script>

  </body>
</html>